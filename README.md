## 消息推送逻辑
### 持久化
- 基于消息唯一标识实现幂等。

### 推送
- 基于乐观锁/悲观锁实现推送幂等。


# 可靠性分析
- 在WebSocket通信中，服务端需要知晓客户端成功接收并处理消息，需要区分 TCP传输层确认 和 应用层确认 两个层面:
    - 前者是协议内置的基础保障
    - 后者需要结合业务场景自定义实现
- TCP传输层的基础确认 不代表 应用层接收。
    - WebSocket协议基于TCP协议实现，而TCP协议本身是"可靠传输协议"，具备"三次握手、字节流确认(ACK)、重传"等机制。
    - 当服务端通过WebSocket发送消息后，TCP协议栈会自动向服务器端返回"ACK确认"，表示"客户端的TCP层已成功收到该数据段"。
    - 但是，TCP层的ACK仅能确认"数据到达客户端的操作系统内核"，无法确认"客户端应用层已成功读取、解析并处理消息"。
    - 比如: 客户端TCP层收到数据，但应用层代码崩溃、代码Bug未读取缓冲区数据，此时TCP仍会返回ACK，但业务上等于"未接收"。

- 原生WebSocket协议的局限: 无内置应用层确认
    - Ping/Pong帧用于检测连接存活状态，不能确认消息已接收。
    - Close帧用于优雅断连，与消息确认无关。

- 自定义应用层消息确认机制
    - 服务端发送消息
    - 客户端回复ACK
    - 服务端确认ACK
    - 超时重发、消息去重等机制

# 聊天室场景
## 在线用户的消息实时分发
- 消息接收与校验
- 消息持久化存储
- 在线用户筛选
- 消息主动推送
- 消息状态变更

## 离线用户历史记录同步
- 离线同步的触发时机
    - 用户登录后，同步聊天室历史信息
    - 用户离线后重新连接聊天室时

- 历史记录的存储与拉取策略
    - 热点缓存层: 近1小时的消息
    - 持久存储层: 所有历史消息

- 避免重复同步
    - 基于消息ID唯一标识去重

## 同步的可靠性与一致性
- 消息确认机制：避免推送丢失
- 消息顺序保证：按时间戳排序
- 大群聊的性能优化: 分片/限流
    - 消息分片推送：将在线用户分为多个批次，分批次推送。
    - 合并小消息：需要客户端支持批量解析
    - 读写分离
